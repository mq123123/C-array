# 指针

## 运算符

* scanf("%d",&i);里的&

* &是取址运算符，获得变量的地址，它的操作数必须是变量

* ```
  int i; printf("%x",&i);
  ```

* 地址的大小是否与int 相同取决于编译器(32位或64位)

* int i ;printf("%p",&i);

<img src="C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202083021639.png" alt="image-20201202083021639" style="zoom:50%;" />

<img src="C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202083135488.png" alt="image-20201202083135488" style="zoom:50%;" />

变量的地址是自顶向下的。i是先创建的变量，p是后创建的变量。

对于数组相邻元素的地址差值永远是4。

## scanf

*    将我们的地址交给它，他将我们的输入赋值给这个地址。

## 指针

* 就是保存地址的变量

  int i;

  int * p  = &i;

  int * p,q;q只是一个普通的一个Int变量。

  int *p,q;

## 指针变量

* 变量的值是内存的地址
* 不同变量的值是实际的值
* 指针变量的值是具有实际值的变量的地址

![image-20201202083944806](C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202083944806.png)

## 作为参数的指针

* ```
  void f(int *p);（直接传地址）
  ```

* 在被调用的时候得到了某个变量的地址；

* ```
  int i = 0; f(&i);
  ```

* 在函数里面可以通过这个指针访问外面这个I

## 访问那个地址上的变量* 

* *是一个单目运算符，用来访问指针的值所表示地址上的变量
* 可以做右值也可以做左值
* int k =*p;
* *p =k+1;

![image-20201202085240356](C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202085240356.png)

此时传递给p的是&i；而不是*p = &x

* ## *左值之所以叫左值

* 是因为出现在赋值浩左边的不是变量，而是值，是表达式计算的结果：

* a[0] = 2;

* *p = 3;

* 是特殊的值，所以叫左值

## 传入地址

* 为什么：  int i;scanf("%d",i),编译器没报错？

他以为I就是一个地址，直接拿他来做事，但是运行会出错，因为那个地址很小，根本放不了你的数字，而且那个地方很重要，不能被更改。

## 指针应用场景1

* 交换两个变量的值

* ```
  void swap(int* pa, int* pb)
  {
  	int t = *pa;
  	*pa = *pb;
  	*pb = t;
  }（直接对两个参数指针进行操作）
  ```

  ## 应用场景2

* 函数返回多个值，某些值就只能通过指针返回

* 传入的参数实际上需要保存带回的结果和变量

返回值不止一个变量，就传递多个指针，用指针把结果带出来。

## 应用场景2b

* 函数返回运算的状态，结果通过指针返回

* 常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错：
* -1或0
* 但是当任何数值都是有效的可能结果时，就得分开返回了。

## 指针的最常见的错误

* 定义了指针变量，还没有指向任何变量，就开始使用指针。

如果

```
int *p = 0;
```

p的值是没有经过赋值的，可能什么都没有，也可能是乱七八糟的地址，如果这个初始化的地址正好指向一个不能赋值的地址，那么程序就马上会崩溃。

（**不崩溃算你运气好**）

## 指针与数组

一个指针的大小/一个地址的大小--4字节

<img src="C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202092421405.png" alt="image-20201202092421405" style="zoom:50%;" />

## 数组变量是特殊的指针s

* 数组变量本身表达地址，所以
* int a[10];int *p = a//无需用&取地址
* 但是数组的单元表达的是变量，需要用&取地址。

* []运算符可以对数组做，也可以对指针做：
* p[0]<==>a[0]
* *运算符可以对指针做，也可以对数组做
*  数组a[]a是一个常量值const 不能修改

## 指针和const

### 指针是const

* 表示一旦得到了某个变量的地址，不能再指向其他变量
* int *const q = &i;//q是const
* *q = 26//OK
* q++;//ERROR

### 所指是const

* 表示不能通过这个指针去修改那个变量**并不能使得那个变量成为const**
* const int *p = &i;//不能通过p去做修改 ，并没有表明说不能修改p 或者是i
* *p = 26;//ERROR! *p 是常量
* i = 26//OK
* p = &j;//OK

<img src="C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202111635296.png" alt="image-20201202111635296" style="zoom:50%;" />

**如果*在const的后面 表示不能通过指针去修改指向的值，而 *在const的后面则表示指针不能被修改，即指针变量是一个常量p==>const.**

### 转换

* 总是可以把一个非const的值转换成const的

  ```
  void f(const int*x);
  int a =15;
  f(&a);//ok
  const int b  = a ;
  
  f(&b);//OK
  b = a +1;//ERROR
  ```

  

* 当要传递的参数的类型比地址大的时候，这是常用的手段;机能用比较少的字数传递值给参数，有呢呢避免函数对外面的变量的修改。

### const数组

* const int a[]={1,2,2,2,3,};
* 数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int
* 所以必须通过初始化进行赋值

### 保护数组值

* 因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值
* 为了保护数组不被函数破话，可以设置参数为const
* int sum[const int a[],int lenth];

## 指针运算

![image-20201202135939681](C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202135939681.png)

当我们在指针的指针变量（地址值）上进行运算时，1代表的是一个 数据类型的单位。

**计算机16进制的运算方法：**

![image-20201202140353846](C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202140353846.png)

* 对指针进行加一是加的sizeof(数据类型)
* *是单目运算符，优先级高于+、- 

<img src="C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202140834872.png" alt="image-20201202140834872" style="zoom:50%;" />

* 如果市镇不是指向一片连续分配的空间，加数组，这种运算没有意义。

### 指针计算

* 这些算数运算可以对指针做;
  * 给指针加、减一个整数（+、+=、-、-=）
  * 递增递减指针
  * 两个指针可以相减
    * 相减就是指针算出来的16进制/sizeof(x)

### *p++

* 取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
* *的优先级虽然高，但是没有++高
* 冲用于数组类的连续空间操作
* 在某些cpu上，这可以直接被翻译成一条汇编指令

![image-20201202141837923](C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202141837923.png)

![image-20201202141847835](C:\Users\33640\AppData\Roaming\Typora\typora-user-images\image-20201202141847835.png)

**利用指针的特殊遍历数组的方法**--设立一个特殊值==>结尾的一个标志

### 指针比较

* < <= == > >= != 都可以对指针使用
* 比较他们在内存中的地址
* 数组中的单元的地址肯定是线性递增的

### 0地址

* 当然你的内存中有0地址，但是0地址通常是个不能随便碰的地址

* 所以你的指针不应该具有0值‘

* 因此可以用0地址来表示特殊的事情

  * 返回的地址是无效的
  * 指针没有被真正初始化（先初始化为0）

* null是一个预定定义的符号，表示0地址

  有的编译器不愿意你用0来表示0地址

### 指针的类型转换

* void*表示**不知道指向什么东西的指针**

  * 计算时与char*相同(但不相通)

* 指针可以转换类型

  * int*p =&i ; void *q = (void*)p

* 这并不改变p所指向变量的类型，而是让后人用不同的眼光通过p看它所指的变量

  

==>通常用于底层的程序（操作系统）

### 用指针来做什么？

* 需要传入较大的数据时用作参数
* 传入数组后对数组做操作
* 函数返回不止一个结果
* 需要用函数修改不止一个变量
* 动态申请的内存...

## 动态内存分配

## 输入数据

* 如果输入数据时，先告诉你个数，然后再输入，要记录每个数据

* C99可以用变量做数组定义的大小，C99之前必须使用动态内存分配

* ```
  int *a = (int*)malloc(n*sizeof(int))	
  ```

  